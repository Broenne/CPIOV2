/*
 * myCanFunctions.c
 *
 *  Created on: 29.11.2018
 *      Author: MB
 */

#include "myCanFunctions.h"


extern fn_ptr;

static uint8_t globalCanId = 2;


osThreadId canInputTask;
/*
 * Created on: 30.11.18
 * Author: MB
 * Diese Funktion initialisiert die Queue
 * Diese und startet den task um diese abzuarbeiten.
 * */
void InitCanInputTask(void) {

	//  /* Create the thread(s) */
	//  /* definition and creation of defaultTask */
	osThreadDef(myTask03, SendPulsePerCanTask, osPriorityAboveNormal, 0, 128);
	myTask03Handle = osThreadCreate(osThread(myTask03), NULL);


	// todo mb: wann und wie den task deleten?
	/* The task was created.  Use the task's handle to delete the task. */
	//vTaskDelete( xHandle );
}


void PrepareCan(void) {
	globalCanId = GetGloablCanIdFromEeeprom(); // set Methode kan wegen reset nicht genutzt weden
}

uint8_t GetGlobalCanNodeId() {
	return globalCanId;
}

void SetGlobalCanNodeId(uint8_t canId) {
	// todo mb: einschränken
	SafeGlobalCanId(canId);
	Reset();
	//globalCanId = canId;
}

void SendCanTimeDif(uint8_t channel, uint32_t res) {
	uint8_t p[] = { 0, 0, 0, 0 };

	// cast timestamp to can info
	p[0] = (res >> 24) & 0xFF;
	p[1] = (res >> 16) & 0xFF;
	p[2] = (res >> 8) & 0xFF;
	p[3] = res & 0xFF;

	uint32_t canId = 0x180 + GetGlobalCanNodeId() + channel;
	SendCan(canId, p, 4);
}



void GetInputs(uint8_t* data){
	uint8_t val[2];
	val [0] = ReadInputsFromRegisterA();
	val [1]= 0; // muss der auf 0 vorher?
	val [1] = ReadInputsFromRegisterB();
	val [1] = (ReadInputsFromRegisterC() << 2 ) | val [1];
	memcpy(data, val,2);
}

